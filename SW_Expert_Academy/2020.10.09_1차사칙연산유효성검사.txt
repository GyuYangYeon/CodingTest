#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define ABS(a) (a)<0?(-a):(a)

#define MAX_N 10000
int front;
int rear;
int queue[MAX_N];
void queueInit(void)
{
	front = 0;
	rear = 0;
}
int queueIsEmpty(void)
{
	return (front == rear);
}
int queueIsFull(void)
{
	if ((rear + 1) % MAX_N == front)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
int queueEnqueue(int value)
{
	if (queueIsFull())
	{
		printf("queue is full!");
		return 0;
	}
	queue[rear] = value;
	rear++;
	if (rear == MAX_N)
	{
		rear = 0;
	}

	return 1;
}
int queueDequeue(int *value)
{
	if (queueIsEmpty())
	{
		printf("queue is empty!");
		return 0;
	}
	*value = queue[front];
	front++;
	if (front == MAX_N)
	{
		front = 0;
	}
	return 1;
}
int queueSize(){
	int temp = front - rear;
	return ABS(temp);
}

#define MAX_NODE_NUM 1000
#define MAX_CHILD_NUM 2
#define LEFT 0
#define RIGTH 1
typedef struct
{
	int parent;
	char Value;
	int child[MAX_CHILD_NUM];
} TreeNode;
TreeNode tree[MAX_NODE_NUM];
int nodeNum;
int edgeNum;
int root;
void initTree(void)
{
	int i;
	int j;
	for (i = 0; i <= nodeNum; i++)
	{
		tree[i].parent = -1;
		for (j = 0; j < MAX_CHILD_NUM; j++)
		{
			tree[i].child[j] = -1;
		}
	}
}
void addChild(int parent, int child)
{
	int i;
	for (i = 0; i < MAX_CHILD_NUM; i++)
	{
		if (tree[parent].child[i] == -1)
		{
			break;
		}
	}
	tree[parent].child[i] = child;
	tree[child].parent = parent;
}
int getRoot(void)
{
	int i;
	int j;
	for (i = 1; i <= nodeNum; i++)
	{
		if (tree[i].parent == -1)
		{
			return i;
		}
	}
	return -1;
}
void BackOrder(int root)
{
	int i;
	int child;
	printf("%d ", root);

	for (i = 0; i < MAX_CHILD_NUM; i++)
	{
		child = tree[root].child[i];
		if (child != -1)
		{
			BackOrder(child);
		}
	}
}

int main(void)
{
	for (int q = 1; q <= 10; q++){
		
		queueInit();
		initTree();

		int Node = 0;
		scanf("%d", &Node);

		for (int i = 0; i < Node; i++){
			char input[14] = { 0 };

			scanf(" %[^\n]s", input);

			//문장별로 파싱 시작
			int index=0;
			int chtoint = 0;
			int pNode = 0;
			int cNode_L = 0;
			int cNode_R = 0;

			//부모노드
			for (index = 0; input[index] != ' '; index++){
				chtoint *= 10;
				chtoint += input[index] - '0';
			}
			pNode = chtoint;

			//연산자
			while (input[index] == ' ') 
				index++;
			tree[pNode].Value = input[index++];

			//왼쪽 자식 노드
			while (input[index] == ' ')
				index++;
			chtoint = 0;
			for (index; input[index] != ' '; index++){
				chtoint *= 10;
				chtoint += input[index] - '0';
			}
			cNode_L = chtoint;

			//오른쪽 자식 노드
			while (input[index] == ' ')
				index++;
			chtoint = 0;
			for (index; (input[index] != 0); index++){
				chtoint *= 10;
				chtoint += input[index] - '0';
			}
			cNode_R = chtoint;


			//파싱된 값 Update
			tree[pNode].child[LEFT] = cNode_L;
			tree[pNode].child[RIGTH] = cNode_R;

			//값 갱신 완료

		}


				
	}

	return 0;
}