//삼성 코테 기출 탈주범 검거


#include <queue>
#include <iostream>
#include <algorithm>
#include <cstring>

#define MAX 50
#define BOUNDARY(a,b,aa, bb) (((a)>=0)&&((b)>=0)&&((a)<(aa))&&((b)<(bb)))
#define UP 0
#define RIGHT 1
#define DOWN 2
#define RIGHT 3


//0 1 2 3 상 우 하 좌

#define TUNUL1 {1,1,1,1}
#define TUNUL2 {1,0,1,0}
#define TUNUL3 {0,1,0,1}
#define TUNUL4 {1,1,0,0}
#define TUNUL5 {0,1,1,0}
#define TUNUL6 {0,0,1,1}
#define TUNUL7 {1,0,0,1}


struct XY
{
	//0 상
	//1 우
	//2 하
	//3 좌
	bool dir[4];
	bool block;
	int Cnt;

	XY() :block(0), Cnt(0){}
};

XY MAP[MAX][MAX];
bool visited[MAX][MAX] = { 0, };
int Cnt_MAP[MAX][MAX] = { 0, };

int sero, garo, start_y, start_x, time = 0;
int res = 0;
//탐색 우선순위도 상우하좌 순
int dx[] = { 0, 1, 0, -1 };
int dy[] = {-1, 0, 1,  0 };
using namespace std;

void BFS(int x, int y){

	//1-> x, 2-> y
	queue<pair<int, int>> q;
	q.push(make_pair(x, y));

	int time_tmp = 0;
	while (!q.empty())
	{

		if (time_tmp == time) break;

		int cx = q.front().first;
		int cy = q.front().second;
		q.pop();
		int nx = cx;
		int ny = cy;

		visited[cy][cx] = true;

		for (int dir = 0; dir < 4; dir++){

			//현재 좌표에서 다음 터널로 갈 수 없을 경우
			if (!MAP[cy][cx].dir[dir]) continue;

			//다음 좌표값 갱신
			nx =  cx + dx[dir];
			ny =  cy + dy[dir];
			//다음 터널에 갈 수 있는 조건문 -> 바운더리 내에 있고 방문하지 않았으며 다음 좌표에서 통로가 열려 있을 떄
			if (!BOUNDARY(nx, ny, garo, sero)) continue;
			if (visited[ny][nx]) continue;
			if ((MAP[cy][cx].dir[dir]==1) &&(MAP[ny][nx].dir[(dir + 2) % 4]==1)){

				visited[ny][nx] = 1;
				Cnt_MAP[ny][nx] = Cnt_MAP[cy][cx] + 1;
				res++;
				MAP[ny][nx].Cnt = MAP[cy][cx].Cnt + 1;
				time_tmp = MAP[ny][nx].Cnt;
				q.push(make_pair(nx, ny));
				

			}
		}

	}

}

int main(){

	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int Test_case = 0;
	cin >> Test_case;

	for (int num = 1; num <= Test_case; num++){

		cin >> sero >> garo >> start_y >> start_x >> time;

		for (int y = 0; y < sero; y++){
			for (int x = 0; x < garo; x++){
				int tmp = 0;
				cin >> tmp;

				if (tmp == 1){
					bool tmp_dir[] = TUNUL1;
					memcpy(MAP[y][x].dir, tmp_dir, sizeof(MAP[y][x].dir));
				}
				else if (tmp == 2){
					bool tmp_dir[] = TUNUL2;
					memcpy(MAP[y][x].dir, tmp_dir, sizeof(MAP[y][x].dir));
				}
				else if (tmp == 3){
					bool tmp_dir[] = TUNUL3;
					memcpy(MAP[y][x].dir, tmp_dir, sizeof(MAP[y][x].dir));
				}
				else if (tmp == 4){
					bool tmp_dir[] = TUNUL4;
					memcpy(MAP[y][x].dir, tmp_dir, sizeof(MAP[y][x].dir));
				}
				else if (tmp == 5){
					bool tmp_dir[] = TUNUL5;
					memcpy(MAP[y][x].dir, tmp_dir, sizeof(MAP[y][x].dir));
				}
				else if (tmp == 6){
					bool tmp_dir[] = TUNUL6;
					memcpy(MAP[y][x].dir, tmp_dir, sizeof(MAP[y][x].dir));
				}
				else if (tmp == 7){
					bool tmp_dir[] = TUNUL7;
					memcpy(MAP[y][x].dir, tmp_dir, sizeof(MAP[y][x].dir));
				}
				else{
					MAP[y][x].block = 1;
				}

			}
		}

		BFS(start_x, start_y);

		cout << '#' << num << ' ' << res << endl;

		memset(visited, 0, sizeof(visited));
		memset(Cnt_MAP,0, sizeof(Cnt_MAP));

		res = 0;
 	}


	return 0;
}